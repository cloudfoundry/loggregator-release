// This file was generated by github.com/nelsam/hel.  Do not
// edit this code by hand unless you *really* know what you're
// doing.  Expect any changes made manually to be overwritten
// the next time hel regenerates this file.

package v1_test

import (
	"sync"

	"github.com/cloudfoundry/dropsonde/metricbatcher"
	"github.com/cloudfoundry/sonde-go/events"
)

type mockConn struct {
	WriteCalled chan bool
	WriteInput  struct {
		Data chan []byte
	}
	WriteOutput struct {
		Ret0 chan error
	}
}

func newMockConn() *mockConn {
	m := &mockConn{}
	m.WriteCalled = make(chan bool, 100)
	m.WriteInput.Data = make(chan []byte, 100)
	m.WriteOutput.Ret0 = make(chan error, 100)
	return m
}
func (m *mockConn) Write(data []byte) error {
	m.WriteCalled <- true
	m.WriteInput.Data <- data
	return <-m.WriteOutput.Ret0
}

type mockBatchCounterChainer struct {
	SetTagCalled chan bool
	SetTagInput  struct {
		Key, Value chan string
	}
	SetTagOutput struct {
		Ret0 chan metricbatcher.BatchCounterChainer
	}
	IncrementCalled chan bool
	AddCalled       chan bool
	AddInput        struct {
		Value chan uint64
	}
}

func newMockBatchCounterChainer() *mockBatchCounterChainer {
	m := &mockBatchCounterChainer{}
	m.SetTagCalled = make(chan bool, 100)
	m.SetTagInput.Key = make(chan string, 100)
	m.SetTagInput.Value = make(chan string, 100)
	m.SetTagOutput.Ret0 = make(chan metricbatcher.BatchCounterChainer, 100)
	m.IncrementCalled = make(chan bool, 100)
	m.AddCalled = make(chan bool, 100)
	m.AddInput.Value = make(chan uint64, 100)
	return m
}
func (m *mockBatchCounterChainer) SetTag(key, value string) metricbatcher.BatchCounterChainer {
	m.SetTagCalled <- true
	m.SetTagInput.Key <- key
	m.SetTagInput.Value <- value
	return <-m.SetTagOutput.Ret0
}
func (m *mockBatchCounterChainer) Increment() {
	m.IncrementCalled <- true
}
func (m *mockBatchCounterChainer) Add(value uint64) {
	m.AddCalled <- true
	m.AddInput.Value <- value
}

type mockBatchCounterIncrementer struct {
	BatchIncrementCounterCalled chan bool
	BatchIncrementCounterInput  struct {
		Name chan string
	}
}

func newMockBatchCounterIncrementer() *mockBatchCounterIncrementer {
	m := &mockBatchCounterIncrementer{}
	m.BatchIncrementCounterCalled = make(chan bool, 100)
	m.BatchIncrementCounterInput.Name = make(chan string, 100)
	return m
}
func (m *mockBatchCounterIncrementer) BatchIncrementCounter(name string) {
	m.BatchIncrementCounterCalled <- true
	m.BatchIncrementCounterInput.Name <- name
}

type MockByteArrayWriter struct {
	data [][]byte
	lock sync.RWMutex
}

func (m *MockByteArrayWriter) Write(p []byte) {
	m.lock.Lock()
	defer m.lock.Unlock()
	m.data = append(m.data, p)
}

func (m *MockByteArrayWriter) Data() [][]byte {
	m.lock.RLock()
	defer m.lock.RUnlock()
	return m.data
}

func (m *MockByteArrayWriter) Weight() int {
	return 0
}

type mockBatchChainByteWriter struct {
	WriteCalled chan bool
	WriteInput  struct {
		Message  chan []byte
		Chainers chan []metricbatcher.BatchCounterChainer
	}
	WriteOutput struct {
		Err chan error
	}
}

func newMockBatchChainByteWriter() *mockBatchChainByteWriter {
	m := &mockBatchChainByteWriter{}
	m.WriteCalled = make(chan bool, 100)
	m.WriteInput.Message = make(chan []byte, 100)
	m.WriteInput.Chainers = make(chan []metricbatcher.BatchCounterChainer, 100)
	m.WriteOutput.Err = make(chan error, 100)
	return m
}
func (m *mockBatchChainByteWriter) Write(message []byte, chainers ...metricbatcher.BatchCounterChainer) (err error) {
	m.WriteCalled <- true
	m.WriteInput.Message <- message
	m.WriteInput.Chainers <- chainers
	return <-m.WriteOutput.Err
}

type mockDroppedMessageCounter struct {
	DropCalled chan bool
	DropInput  struct {
		Count chan uint32
	}
}

func newMockDroppedMessageCounter() *mockDroppedMessageCounter {
	m := &mockDroppedMessageCounter{}
	m.DropCalled = make(chan bool, 100)
	m.DropInput.Count = make(chan uint32, 100)
	return m
}
func (m *mockDroppedMessageCounter) Drop(count uint32) {
	m.DropCalled <- true
	m.DropInput.Count <- count
}

type MockEnvelopeWriter struct {
	Events     []*events.Envelope
	eventsLock sync.Mutex
}

func (m *MockEnvelopeWriter) Write(event *events.Envelope) {
	m.eventsLock.Lock()
	defer m.eventsLock.Unlock()
	m.Events = append(m.Events, event)
}

type mockEventBatcher struct {
	BatchCounterCalled chan bool
	BatchCounterInput  struct {
		Name chan string
	}
	BatchCounterOutput struct {
		Chainer chan metricbatcher.BatchCounterChainer
	}
	BatchIncrementCounterCalled chan bool
	BatchIncrementCounterInput  struct {
		Name chan string
	}
}

func newMockEventBatcher() *mockEventBatcher {
	m := &mockEventBatcher{}
	m.BatchCounterCalled = make(chan bool, 100)
	m.BatchCounterInput.Name = make(chan string, 100)
	m.BatchCounterOutput.Chainer = make(chan metricbatcher.BatchCounterChainer, 100)
	m.BatchIncrementCounterCalled = make(chan bool, 100)
	m.BatchIncrementCounterInput.Name = make(chan string, 100)
	return m
}
func (m *mockEventBatcher) BatchCounter(name string) (chainer metricbatcher.BatchCounterChainer) {
	m.BatchCounterCalled <- true
	m.BatchCounterInput.Name <- name
	return <-m.BatchCounterOutput.Chainer
}
func (m *mockEventBatcher) BatchIncrementCounter(name string) {
	m.BatchIncrementCounterCalled <- true
	m.BatchIncrementCounterInput.Name <- name
}

type mockMetricBatcher struct {
	BatchIncrementCounterCalled chan bool
	BatchIncrementCounterInput  struct {
		Name chan string
	}
	BatchAddCounterCalled chan bool
	BatchAddCounterInput  struct {
		Name  chan string
		Delta chan uint64
	}
	CloseCalled chan bool
}

func newMockMetricBatcher() *mockMetricBatcher {
	m := &mockMetricBatcher{}
	m.BatchIncrementCounterCalled = make(chan bool, 100)
	m.BatchIncrementCounterInput.Name = make(chan string, 100)
	m.BatchAddCounterCalled = make(chan bool, 100)
	m.BatchAddCounterInput.Name = make(chan string, 100)
	m.BatchAddCounterInput.Delta = make(chan uint64, 100)
	m.CloseCalled = make(chan bool, 100)
	return m
}
func (m *mockMetricBatcher) BatchIncrementCounter(name string) {
	m.BatchIncrementCounterCalled <- true
	m.BatchIncrementCounterInput.Name <- name
}
func (m *mockMetricBatcher) BatchAddCounter(name string, delta uint64) {
	m.BatchAddCounterCalled <- true
	m.BatchAddCounterInput.Name <- name
	m.BatchAddCounterInput.Delta <- delta
}
func (m *mockMetricBatcher) Close() {
	m.CloseCalled <- true
}
