// Code generated by protoc-gen-go. DO NOT EDIT.
// source: egress.proto

package loggregator_v2

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type EgressRequest struct {
	// shard_id instructs Loggregator to shard envelopes between other
	// subscriptions with the same shard_id. Loggregator will do its best to
	// split the load evenly between subscriptions with the same shard_id.
	ShardId string `protobuf:"bytes,1,opt,name=shard_id,json=shardId" json:"shard_id,omitempty"`
	// TODO: This can be removed once selector has been around long enough.
	LegacySelector *Selector `protobuf:"bytes,2,opt,name=legacy_selector,json=legacySelector" json:"legacy_selector,omitempty"`
	// selector is the preferred (over legacy_selector) mechanism to select
	// what envelope types the subscription wants.
	Selectors []*Selector `protobuf:"bytes,4,rep,name=selectors" json:"selectors,omitempty"`
	// TODO: This can be removed once the envelope.deprecated_tags is removed.
	UsePreferredTags bool `protobuf:"varint,3,opt,name=use_preferred_tags,json=usePreferredTags" json:"use_preferred_tags,omitempty"`
}

func (m *EgressRequest) Reset()                    { *m = EgressRequest{} }
func (m *EgressRequest) String() string            { return proto.CompactTextString(m) }
func (*EgressRequest) ProtoMessage()               {}
func (*EgressRequest) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{0} }

func (m *EgressRequest) GetShardId() string {
	if m != nil {
		return m.ShardId
	}
	return ""
}

func (m *EgressRequest) GetLegacySelector() *Selector {
	if m != nil {
		return m.LegacySelector
	}
	return nil
}

func (m *EgressRequest) GetSelectors() []*Selector {
	if m != nil {
		return m.Selectors
	}
	return nil
}

func (m *EgressRequest) GetUsePreferredTags() bool {
	if m != nil {
		return m.UsePreferredTags
	}
	return false
}

type EgressBatchRequest struct {
	// shard_id instructs Loggregator to shard envelopes between other
	// subscriptions with the same shard_id. Loggregator will do its best to
	// split the load evenly between subscriptions with the same shard_id.
	ShardId string `protobuf:"bytes,1,opt,name=shard_id,json=shardId" json:"shard_id,omitempty"`
	// TODO: This can be removed once selector has been around long enough.
	LegacySelector *Selector `protobuf:"bytes,2,opt,name=legacy_selector,json=legacySelector" json:"legacy_selector,omitempty"`
	// selector is the preferred (over legacy_selector) mechanism to select
	// what envelope types the subscription wants.
	Selectors []*Selector `protobuf:"bytes,4,rep,name=selectors" json:"selectors,omitempty"`
	// TODO: This can be removed once the envelope.deprecated_tags is removed.
	UsePreferredTags bool `protobuf:"varint,3,opt,name=use_preferred_tags,json=usePreferredTags" json:"use_preferred_tags,omitempty"`
}

func (m *EgressBatchRequest) Reset()                    { *m = EgressBatchRequest{} }
func (m *EgressBatchRequest) String() string            { return proto.CompactTextString(m) }
func (*EgressBatchRequest) ProtoMessage()               {}
func (*EgressBatchRequest) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{1} }

func (m *EgressBatchRequest) GetShardId() string {
	if m != nil {
		return m.ShardId
	}
	return ""
}

func (m *EgressBatchRequest) GetLegacySelector() *Selector {
	if m != nil {
		return m.LegacySelector
	}
	return nil
}

func (m *EgressBatchRequest) GetSelectors() []*Selector {
	if m != nil {
		return m.Selectors
	}
	return nil
}

func (m *EgressBatchRequest) GetUsePreferredTags() bool {
	if m != nil {
		return m.UsePreferredTags
	}
	return false
}

// Selector instructs Loggregator to only send envelopes that match the given
// criteria.
type Selector struct {
	SourceId string `protobuf:"bytes,1,opt,name=source_id,json=sourceId" json:"source_id,omitempty"`
	// Types that are valid to be assigned to Message:
	//	*Selector_Log
	//	*Selector_Counter
	//	*Selector_Gauge
	//	*Selector_Timer
	//	*Selector_Event
	Message isSelector_Message `protobuf_oneof:"Message"`
}

func (m *Selector) Reset()                    { *m = Selector{} }
func (m *Selector) String() string            { return proto.CompactTextString(m) }
func (*Selector) ProtoMessage()               {}
func (*Selector) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{2} }

type isSelector_Message interface {
	isSelector_Message()
}

type Selector_Log struct {
	Log *LogSelector `protobuf:"bytes,2,opt,name=log,oneof"`
}
type Selector_Counter struct {
	Counter *CounterSelector `protobuf:"bytes,3,opt,name=counter,oneof"`
}
type Selector_Gauge struct {
	Gauge *GaugeSelector `protobuf:"bytes,4,opt,name=gauge,oneof"`
}
type Selector_Timer struct {
	Timer *TimerSelector `protobuf:"bytes,5,opt,name=timer,oneof"`
}
type Selector_Event struct {
	Event *EventSelector `protobuf:"bytes,6,opt,name=event,oneof"`
}

func (*Selector_Log) isSelector_Message()     {}
func (*Selector_Counter) isSelector_Message() {}
func (*Selector_Gauge) isSelector_Message()   {}
func (*Selector_Timer) isSelector_Message()   {}
func (*Selector_Event) isSelector_Message()   {}

func (m *Selector) GetMessage() isSelector_Message {
	if m != nil {
		return m.Message
	}
	return nil
}

func (m *Selector) GetSourceId() string {
	if m != nil {
		return m.SourceId
	}
	return ""
}

func (m *Selector) GetLog() *LogSelector {
	if x, ok := m.GetMessage().(*Selector_Log); ok {
		return x.Log
	}
	return nil
}

func (m *Selector) GetCounter() *CounterSelector {
	if x, ok := m.GetMessage().(*Selector_Counter); ok {
		return x.Counter
	}
	return nil
}

func (m *Selector) GetGauge() *GaugeSelector {
	if x, ok := m.GetMessage().(*Selector_Gauge); ok {
		return x.Gauge
	}
	return nil
}

func (m *Selector) GetTimer() *TimerSelector {
	if x, ok := m.GetMessage().(*Selector_Timer); ok {
		return x.Timer
	}
	return nil
}

func (m *Selector) GetEvent() *EventSelector {
	if x, ok := m.GetMessage().(*Selector_Event); ok {
		return x.Event
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Selector) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Selector_OneofMarshaler, _Selector_OneofUnmarshaler, _Selector_OneofSizer, []interface{}{
		(*Selector_Log)(nil),
		(*Selector_Counter)(nil),
		(*Selector_Gauge)(nil),
		(*Selector_Timer)(nil),
		(*Selector_Event)(nil),
	}
}

func _Selector_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Selector)
	// Message
	switch x := m.Message.(type) {
	case *Selector_Log:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Log); err != nil {
			return err
		}
	case *Selector_Counter:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Counter); err != nil {
			return err
		}
	case *Selector_Gauge:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Gauge); err != nil {
			return err
		}
	case *Selector_Timer:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Timer); err != nil {
			return err
		}
	case *Selector_Event:
		b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Event); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Selector.Message has unexpected type %T", x)
	}
	return nil
}

func _Selector_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Selector)
	switch tag {
	case 2: // Message.log
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(LogSelector)
		err := b.DecodeMessage(msg)
		m.Message = &Selector_Log{msg}
		return true, err
	case 3: // Message.counter
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CounterSelector)
		err := b.DecodeMessage(msg)
		m.Message = &Selector_Counter{msg}
		return true, err
	case 4: // Message.gauge
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GaugeSelector)
		err := b.DecodeMessage(msg)
		m.Message = &Selector_Gauge{msg}
		return true, err
	case 5: // Message.timer
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TimerSelector)
		err := b.DecodeMessage(msg)
		m.Message = &Selector_Timer{msg}
		return true, err
	case 6: // Message.event
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EventSelector)
		err := b.DecodeMessage(msg)
		m.Message = &Selector_Event{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Selector_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Selector)
	// Message
	switch x := m.Message.(type) {
	case *Selector_Log:
		s := proto.Size(x.Log)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Selector_Counter:
		s := proto.Size(x.Counter)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Selector_Gauge:
		s := proto.Size(x.Gauge)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Selector_Timer:
		s := proto.Size(x.Timer)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Selector_Event:
		s := proto.Size(x.Event)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// LogSelector instructs Loggregator to egress Log envelopes to the given
// subscription.
type LogSelector struct {
}

func (m *LogSelector) Reset()                    { *m = LogSelector{} }
func (m *LogSelector) String() string            { return proto.CompactTextString(m) }
func (*LogSelector) ProtoMessage()               {}
func (*LogSelector) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{3} }

// GaugeSelector instructs Loggregator to egress Gauge envelopes to the
// given subscription.
type GaugeSelector struct {
}

func (m *GaugeSelector) Reset()                    { *m = GaugeSelector{} }
func (m *GaugeSelector) String() string            { return proto.CompactTextString(m) }
func (*GaugeSelector) ProtoMessage()               {}
func (*GaugeSelector) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{4} }

// CounterSelector instructs Loggregator to egress Counter envelopes to the
// given subscription
type CounterSelector struct {
}

func (m *CounterSelector) Reset()                    { *m = CounterSelector{} }
func (m *CounterSelector) String() string            { return proto.CompactTextString(m) }
func (*CounterSelector) ProtoMessage()               {}
func (*CounterSelector) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{5} }

// TimerSelector instructs Loggregator to egress Timer envelopes to the given
// subscription.
type TimerSelector struct {
}

func (m *TimerSelector) Reset()                    { *m = TimerSelector{} }
func (m *TimerSelector) String() string            { return proto.CompactTextString(m) }
func (*TimerSelector) ProtoMessage()               {}
func (*TimerSelector) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{6} }

// EventSelector instructs Loggregator to egress Event envelopes to the given
// subscription.
type EventSelector struct {
}

func (m *EventSelector) Reset()                    { *m = EventSelector{} }
func (m *EventSelector) String() string            { return proto.CompactTextString(m) }
func (*EventSelector) ProtoMessage()               {}
func (*EventSelector) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{7} }

func init() {
	proto.RegisterType((*EgressRequest)(nil), "loggregator.v2.EgressRequest")
	proto.RegisterType((*EgressBatchRequest)(nil), "loggregator.v2.EgressBatchRequest")
	proto.RegisterType((*Selector)(nil), "loggregator.v2.Selector")
	proto.RegisterType((*LogSelector)(nil), "loggregator.v2.LogSelector")
	proto.RegisterType((*GaugeSelector)(nil), "loggregator.v2.GaugeSelector")
	proto.RegisterType((*CounterSelector)(nil), "loggregator.v2.CounterSelector")
	proto.RegisterType((*TimerSelector)(nil), "loggregator.v2.TimerSelector")
	proto.RegisterType((*EventSelector)(nil), "loggregator.v2.EventSelector")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Egress service

type EgressClient interface {
	Receiver(ctx context.Context, in *EgressRequest, opts ...grpc.CallOption) (Egress_ReceiverClient, error)
	BatchedReceiver(ctx context.Context, in *EgressBatchRequest, opts ...grpc.CallOption) (Egress_BatchedReceiverClient, error)
}

type egressClient struct {
	cc *grpc.ClientConn
}

func NewEgressClient(cc *grpc.ClientConn) EgressClient {
	return &egressClient{cc}
}

func (c *egressClient) Receiver(ctx context.Context, in *EgressRequest, opts ...grpc.CallOption) (Egress_ReceiverClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Egress_serviceDesc.Streams[0], c.cc, "/loggregator.v2.Egress/Receiver", opts...)
	if err != nil {
		return nil, err
	}
	x := &egressReceiverClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Egress_ReceiverClient interface {
	Recv() (*Envelope, error)
	grpc.ClientStream
}

type egressReceiverClient struct {
	grpc.ClientStream
}

func (x *egressReceiverClient) Recv() (*Envelope, error) {
	m := new(Envelope)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *egressClient) BatchedReceiver(ctx context.Context, in *EgressBatchRequest, opts ...grpc.CallOption) (Egress_BatchedReceiverClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Egress_serviceDesc.Streams[1], c.cc, "/loggregator.v2.Egress/BatchedReceiver", opts...)
	if err != nil {
		return nil, err
	}
	x := &egressBatchedReceiverClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Egress_BatchedReceiverClient interface {
	Recv() (*EnvelopeBatch, error)
	grpc.ClientStream
}

type egressBatchedReceiverClient struct {
	grpc.ClientStream
}

func (x *egressBatchedReceiverClient) Recv() (*EnvelopeBatch, error) {
	m := new(EnvelopeBatch)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for Egress service

type EgressServer interface {
	Receiver(*EgressRequest, Egress_ReceiverServer) error
	BatchedReceiver(*EgressBatchRequest, Egress_BatchedReceiverServer) error
}

func RegisterEgressServer(s *grpc.Server, srv EgressServer) {
	s.RegisterService(&_Egress_serviceDesc, srv)
}

func _Egress_Receiver_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(EgressRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(EgressServer).Receiver(m, &egressReceiverServer{stream})
}

type Egress_ReceiverServer interface {
	Send(*Envelope) error
	grpc.ServerStream
}

type egressReceiverServer struct {
	grpc.ServerStream
}

func (x *egressReceiverServer) Send(m *Envelope) error {
	return x.ServerStream.SendMsg(m)
}

func _Egress_BatchedReceiver_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(EgressBatchRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(EgressServer).BatchedReceiver(m, &egressBatchedReceiverServer{stream})
}

type Egress_BatchedReceiverServer interface {
	Send(*EnvelopeBatch) error
	grpc.ServerStream
}

type egressBatchedReceiverServer struct {
	grpc.ServerStream
}

func (x *egressBatchedReceiverServer) Send(m *EnvelopeBatch) error {
	return x.ServerStream.SendMsg(m)
}

var _Egress_serviceDesc = grpc.ServiceDesc{
	ServiceName: "loggregator.v2.Egress",
	HandlerType: (*EgressServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Receiver",
			Handler:       _Egress_Receiver_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "BatchedReceiver",
			Handler:       _Egress_BatchedReceiver_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "egress.proto",
}

func init() { proto.RegisterFile("egress.proto", fileDescriptor1) }

var fileDescriptor1 = []byte{
	// 425 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x94, 0xc1, 0x6e, 0xd3, 0x40,
	0x10, 0x86, 0xbb, 0x4d, 0x9b, 0xd8, 0x13, 0x12, 0xc3, 0x9e, 0x96, 0x54, 0x15, 0x96, 0x4f, 0x39,
	0x20, 0x83, 0x8c, 0xe0, 0xc2, 0x89, 0xa2, 0xa8, 0x54, 0x02, 0x09, 0x99, 0x1e, 0xb8, 0x59, 0x8b,
	0x3d, 0x6c, 0x23, 0x99, 0x6c, 0xd8, 0x5d, 0x5b, 0xe2, 0x99, 0x78, 0x0e, 0x9e, 0x80, 0x0b, 0x8f,
	0x83, 0x76, 0x1d, 0xb7, 0xb6, 0x13, 0x78, 0x80, 0x1e, 0x77, 0xff, 0xff, 0x9b, 0x99, 0xdf, 0x9a,
	0x35, 0x3c, 0x40, 0xa1, 0x50, 0xeb, 0x78, 0xab, 0xa4, 0x91, 0x74, 0x5e, 0x4a, 0x21, 0x14, 0x0a,
	0x6e, 0xa4, 0x8a, 0xeb, 0x64, 0x31, 0xc7, 0x4d, 0x8d, 0xa5, 0xdc, 0x62, 0xa3, 0x47, 0xbf, 0x09,
	0xcc, 0x56, 0x0e, 0x48, 0xf1, 0x7b, 0x85, 0xda, 0xd0, 0xc7, 0xe0, 0xe9, 0x1b, 0xae, 0x8a, 0x6c,
	0x5d, 0x30, 0x12, 0x92, 0xa5, 0x9f, 0x4e, 0xdc, 0xf9, 0xaa, 0xa0, 0x6f, 0x20, 0x28, 0x51, 0xf0,
	0xfc, 0x47, 0xa6, 0xb1, 0xc4, 0xdc, 0x48, 0xc5, 0x8e, 0x43, 0xb2, 0x9c, 0x26, 0x2c, 0xee, 0xb7,
	0x89, 0x3f, 0xed, 0xf4, 0x74, 0xde, 0x00, 0xed, 0x99, 0xbe, 0x02, 0xbf, 0x65, 0x35, 0x3b, 0x09,
	0x47, 0xff, 0x85, 0xef, 0xac, 0xf4, 0x29, 0xd0, 0x4a, 0x63, 0xb6, 0x55, 0xf8, 0x15, 0x95, 0xc2,
	0x22, 0x33, 0x5c, 0x68, 0x36, 0x0a, 0xc9, 0xd2, 0x4b, 0x1f, 0x56, 0x1a, 0x3f, 0xb6, 0xc2, 0x35,
	0x17, 0x3a, 0xfa, 0x43, 0x80, 0x36, 0xa9, 0x2e, 0xb8, 0xc9, 0x6f, 0xee, 0x53, 0xb4, 0x5f, 0xc7,
	0xe0, 0xdd, 0xb6, 0x3c, 0x03, 0x5f, 0xcb, 0x4a, 0xe5, 0x78, 0x97, 0xc8, 0x6b, 0x2e, 0xae, 0x0a,
	0xfa, 0x0c, 0x46, 0xa5, 0x14, 0xbb, 0x18, 0x67, 0xc3, 0x49, 0xde, 0x4b, 0xd1, 0x96, 0x79, 0x77,
	0x94, 0x5a, 0x27, 0x7d, 0x0d, 0x93, 0x5c, 0x56, 0x1b, 0x83, 0xca, 0x75, 0x9f, 0x26, 0x4f, 0x86,
	0xd0, 0xdb, 0x46, 0xee, 0x80, 0x2d, 0x41, 0x5f, 0xc2, 0xa9, 0xe0, 0x95, 0x40, 0x76, 0xe2, 0xd0,
	0xf3, 0x21, 0x7a, 0x69, 0xc5, 0x0e, 0xd8, 0xb8, 0x2d, 0x66, 0xd6, 0xdf, 0x50, 0xb1, 0xd3, 0xc3,
	0xd8, 0xb5, 0x15, 0xbb, 0x98, 0x73, 0x5b, 0x0c, 0x6b, 0xdc, 0x18, 0x36, 0x3e, 0x8c, 0xad, 0xac,
	0xd8, 0xc5, 0x9c, 0xfb, 0xc2, 0x87, 0xc9, 0x07, 0xd4, 0x9a, 0x0b, 0x8c, 0x66, 0x30, 0xed, 0x7c,
	0x82, 0x28, 0x80, 0x59, 0x6f, 0xc2, 0xe8, 0x11, 0x04, 0x83, 0xb4, 0xd6, 0xd3, 0x1b, 0xc7, 0x5e,
	0xf4, 0x1a, 0x25, 0x3f, 0x09, 0x8c, 0x9b, 0xbd, 0xa3, 0x97, 0xe0, 0xa5, 0x98, 0xe3, 0xba, 0x46,
	0x45, 0xf7, 0xc7, 0xeb, 0xbe, 0xb8, 0xc5, 0xde, 0x96, 0xac, 0x76, 0x6f, 0x34, 0x3a, 0x7a, 0x4e,
	0xe8, 0x67, 0x08, 0xdc, 0x12, 0x63, 0x71, 0x5b, 0x2f, 0x3a, 0x5c, 0xaf, 0xbb, 0xeb, 0x8b, 0xf3,
	0x7f, 0x15, 0x75, 0x2e, 0x5b, 0xf9, 0xcb, 0xd8, 0xfd, 0x02, 0x5e, 0xfc, 0x0d, 0x00, 0x00, 0xff,
	0xff, 0x11, 0x21, 0x4c, 0xff, 0x32, 0x04, 0x00, 0x00,
}
